

\subsection{Translation of structures and arrays}
\label{sec:StructArray}

\subsubsection{Arrays}

The arrays store a fixed-size sequential collection of elements with the same type. 
They consist of contiguous memory locations, where the lowest address (0) 
corresponds to the first element and the highest address to the last element.
In B, a concrete array is a total function where the domain indexes the range 
elements. Declaration examples of arrays are:
\begin{itemize}
	\item $array1 \in (0..10) \to INT $	(a simple array)
	\item $array2 \in (1..10) \times (1..20) \times (1..30) \to INT $   (a multidimensional array)
	\item $\{1\mapsto1\mapsto4, 1\mapsto2\mapsto5\}  \in (INT \times INT) \times INT$ (an explicit array)
\end{itemize} 


\subsubsection{Relation arrays B0 and LLVM}

The arrays in B0 are represented by functions where an index points to an 
element. By default, the element of index not initialized has a zero value. 

This section shows the relation between arrays B0 and LLVM. The sequence of
elements are defining an array, getting an element and setting an
element.

\subsubsection{Declaring an array}

\begin{pascalcode}
array2(1,2,0) := 4;
array2(1,2,1) := 5;
\end{pascalcode}


The LLVM instruction \textit{getelementptr} is used to select an element in
the array or structure. A simple example is: 

\begin{llvmcode}
%7 = getelementptr [10 x [20 x [30 x i32]]]* @Array2, i32 0, i64 2, i64 3, i64 4
\end{llvmcode}


The first two parameters define the type and name of the variable, and the others are indexes to select the element in the data type. The third parameter (i32 0)
selects the first element in the pointer (* @array2). The last elements 
(i64 2, i64 3, i64 4) select the value from position (2,3,4) storing it in \%7.
This array is multidimensional, so several indexes must be declared separated
by comma to get the specific element.

\subsubsection{Setting and getting array}

The following blocks illustrate a B code setting a value to array
and its translation to LLVM. 

\begin{pascalcode} 
VAR xx, yy, zz IN
	xx=2;
	yy=3;
	zz=4;
	array2(x,y,z):=7
END
\end{pascalcode}

This example is translated in four steps. First, the variables \%x, \%y, \%z 
are allocated. Second, the respective values 2, 3, 4 are stored in variables. 
Third, the variables are loaded to local variables and converted to 64 bits. 
Finally, the address of array is calculated in local variable \%7 and the value 
7 is stored in it.  
\begin{figure}[h]
\begin{llvmcode}
%xx = alloca i32
%yy = alloca i32
%zz = alloca i32
store i32 2, i32* %xx
store i32 3, i32* %yy
store i32 4, i32* %zz
%1 = load i32* %zz
%2 = sext i32 %1 to i64
%3 = load i32* %yy
%4 = sext i32 %3 to i64
%5 = load i32* %xx
%6 = sext i32 %5 to i64
%7 = getelementptr[10x[20x[30xi32]]]*@Array2,i32 0,i64 %6,i64 %4,i64 %2;getting an element
store i32 7, i32* %7         ;setting an element
\end{llvmcode}
\end{figure}

\subsubsection{Rules for support array}


\paragraph{Array item} selects an item in expressions as ``$a(n1,...,n_{n})$'', 
where $a$ is $n.base$ and $n1,...,n_{n}$ is a sequence of indexes that 
calculates the address of element. This rule also supports to translate 
expressions of arrays.

\begin{align*}
\lefteqn{\trad{n}{ArrayItem} \isdef} \\
&  \LET p_1 \sep v_1 \sep t_1  = \trad{n.base}{Exp}  \IN \\
&  \LET r \sep p_2  = \trad{n.indexes}{LRExp}  \IN \\
&  \LET v =  \variable \AND  t = \trad{\B{n.type}}{Type}  \IN \\
&  \llvm{"\PH{p_1} \PH{p_2} \PH{v} =  getelementptr \PH{t_1}, \PH{v_1}, i32 0 \PH{r}\nl"}  \sep v \sep t\\
\end{align*}

A list of type and variable is generated by the following rule.
\begin{align*}
&\trad{n}{LRExp} \isdef \LET p \sep v \sep t  = \trad{n}{ShiftExp}  \IN  \llvm{",\PH{t} \PH{v} "} \sep p\\
&\trad{n l}{LRExp} \isdef \LET r_1 \sep p_1 = \trad{n}{LRExp} \AND 
 \LET r_2 \sep p_2 = \trad{l}{LRExp} \IN\\
& \quad  \llvm{"\PH{r_1} \PH{r_2}"} \sep \llvm{"\PH{p_1} \PH{p_2}"}\\
\end{align*}


The element access of array can need a shift in indexes. When the domain of 
array is an interval and it is not started from zero, it must adjust the 
indexes shifting the access, because the addressing  of array in intermediate 
representation LLVM starts at 0. To access an element from array the formula is 
$address(e(i1,..,in))  = i1-i1\_start, ... , in-in\_start$. The following rule 
\footnote{The function $TSymbol$ returns the ``start'', ``end'' and type of the one 
index.} makes the shift for each index of array. \VGM{TODO: The function TSymbol
returns the ``start'', ``end'' and type of the one index.}

\begin{align*}
&\trad{n}{ShiftExp} \isdef \LET p \sep v \sep t  = \trad{n}{Exp} \AND \\ \\
&\quad iStart \sep iEnd \sep iType = \trad{n}{TSymbol}  \AND  \PH{\ell} = \lbl \IN \\
&\quad \IF ( iStart == 0 ) \THEN  \llvm{",\PH{t} \PH{v} "} \sep p \\
&\quad \ELSE \LET  p' \sep v \sep v' \sep t'  = \trad{t,v,itype,istart}{Cast} \IN \\
&\quad \llvm{",\PH{t} \PH{\ell} "} \sep  \llvm{"\PH{p} \PH{p'}  \PH{\ell} = sub \PH{t'} \PH{v}, \PH{v'}\nl"}  \\
\end{align*}

The \trad{}{ShiftExp} rule does a subtraction and this operation must have operators with the same data types so the following cast rule is used:

\begin{align*}
&\trad{t,v,t',v'}{Cast} \isdef \LET  \ell = \lbl \IN \\
&\quad \IF ( t == t') \THEN p \sep v \sep v' \sep t  \\
&\quad \ELSE \IF (t<t') \THEN \\
&\quad \quad \llvm{"\PH{\ell}= bitcast \PH{t} \PH{v} , \PH{t'}\nl"}  \sep l \sep v' \sep t'\\ 
&\quad \ELSE \\ 
&\quad \quad \llvm{"\PH{\ell}= bitcast \PH{t'} \PH{v'} , \PH{t}\nl"} \sep v \sep l \sep t \\ 
\end{align*}

